# Основные черты Kotlin
# Основы Kotlin

## Некоторые новшества Kotlin

- Функцию можно объявить на верхнем уровне в файле - ее не обязательно помещать в класс
- Массивы - это просто классы.
  В отличии от Java, в Kotlin нет специального синтаксиса для объявления массивов
- Вместо `System.out.println` можно писать просто `println`.
  Стандартная библиотека Kotlin включает множество оберток с лаконичным синтаксисом для функций в стандартной библиотеке
- Точку с запятой в конце строки можно опустить

*Жемеров Д., Исакова С. Kotlin в действии. стр.40*

## Объявление функции Kotlin

Объявление начинается с ключевого слова `fun`, за которым следует ее имя.
Далее следует список параметров в круглых скобках.
Тип возвращаемого значения указывается после списка параметров и отделяется от него доветочием.

![fun_decl](img/fun_decl.png)

*Жемеров Д., Исакова С. Kotlin в действии. стр.41*

## `if` - не инструкция, а выражение

В языке Kotlin оператор `if` - это выражение, а не инструкция.
Разница между выражениями и инструкциями состоит в том, что выражение имеет значение, которое можно использовать в других выражениях, в то время, как инструкции всегда являются элементами верхнего уровня в охватывающем блоке и не имеют собственного значения.

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

Похоже на тернарный оператор в Java

*Жемеров Д., Исакова С. Kotlin в действии. стр.41*

## Тело-блок и тело-выражение

Поскольку тело функции состоит из единственного выражения, то им можно заменить всё тело функции, удалив фигурные скобки и инструкцию `return`

```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

Если тело функции заключено в фигурные скобки, мы говорим, что такая функция имеет *тело-блок* (*block body*).
Функция, возвращающая выражение напрямую, имеет *тело-выражение* (*expression body*)

*Жемеров Д., Исакова С. Kotlin в действии. стр.41*

## Когда можно опускать возвращаемого типа функции

Функцию `max` из *Тело-блок и тело-выражение* можно упростить еще больше, опустив тип возвращаемого значения

```kotlin
fun max(a: int, b: Int) = if (a > b) a else b
```

Каждая переменное и каждое выражение имеют тип, и каждая функция имеет тип возвращаемого значения.
Но для <u>функций с телом-выражением</u> компилятор может проанализировать выражение и использовать его  тип в качестве возвращаемого типа.
В <u>функциях с телом-блоком</u> тип возвращаемого значения (если оно имеется) должен указываться явно, и обязательно должна использоваться инструкция `return`

*Жемеров Д., Исакова С. Kotlin в действии. стр.42*

## Объявление переменной

В Java объявление начинается с типа. Такой способ не поддерживается в Kotlin, поскольку он позволяет пропускать типы во многих объявленях переменных. Поэтому в Kotlin объявление начинается с ключевого слова, а тип можно указать (или не указывать) после имени переменной.

```kotlin
val question = "The Ultimate Question of Life, the Universe, and Everything"
val answer = 42
```

*Жемеров Д., Исакова С. Kotlin в действии. стр.42*

## `val` и `var`

Есть 2 ключевых слова для объявления переменной:

- `val` (от value) - неизменяемая ссылка. Аналог финальных переменных в Java
- `var` (от variable) - изменяемая ссылка. Как обычная (не финальная) переменная в Java

По умолчанию вы должны стремиться объявлять все переменные в Kotlin с ключевым словом `val`.
Заменяйте его на `var` только при необходимости.
Использование неизменяемых ссылок и объектов, а также функций без побочных эффектов приблизит ваш код к функциональному стилю.

Переменная, объявленная с ключевым словом `val` должна быть инициализирована только один раз во время выполнения блока, в котором она определена.
Но ее можно инициализировать разными значениями в зависимости от некоторых условий, если компилятор сможет гарантировать, что выполнится одно из инициализирующих выражений.

*Жемеров Д., Исакова С. Kotlin в действии. стр.43*

## Когда указывать тип переменной явно

Если в объявлении переменной отсутствует инициализирующее выражение, ее тип нужно указывать явно.

```kotlin
val answer: Int
answer = 42
```

Компилятор не сможет определить тип, если не дать ему никакой информации о значениях, которые могут быть присвоены этой переменной.

*Жемеров Д., Исакова С. Kotlin в действии. стр.43*

## Тип фиксирован

Хотя ключевое слово `var` позволяет менять значение переменной, но ее тип фиксирован.

*Жемеров Д., Исакова С. Kotlin в действии. стр.44*

## Стоковые шаблоны

```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name")
}
```

Kotlin позволяет использовать ссылки на локальные переменные, добавляя к ним в начало символ `$`.
Чтобы включить в строку символ `$`, его нужно экранировать `println("\$x")`
Вы не ограничены простыми именами переменных, но также можете использовать более сложные выражения.
Для этого достаточно заключить выражение в фигурные скобки

```kotlin
fun main(args: Array<String>) {
    if (args.size > 0) {
        println("Hello {args[0]}")
    }
}
```

Также можно помещать двойные кавычки внутрь других двойных кавычек, пока они входят в состав выражения

```kotlin
fun main(args: Array<String>) {
    println("Hello, {if (args.size > 0) args[0] else "someone"}!")
}
```

*Жемеров Д., Исакова С. Kotlin в действии. стр.44-45*

## Объекты-значения

Классы, содержащие только данные, без кода часто называют *объектами-значениями* (*value objects*).
Данный класс на Java

```java
public class Person {
    private final String name;
    
    public Person(Sting name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}
```

Эквивалентен такому классу на Kotlin

```kotlin
class Person(val name: String)
```

В Kotlin эту логику можно выразить без ненужного шаблонного кода.

*Жемеров Д., Исакова С. Kotlin в действии. стр.46*

## public по умолчанию

В Kotlin область видимости `public` принята по умолчанию, поэтому ее можно не указывать

*Жемеров Д., Исакова С. Kotlin в действии. стр.46*

## Свойства в Kotlin

В Java сочетание поля и методов доступа часто называют *свойством* (*property*).
Свойство в классе объявляется так же, как переменная: с помощью клечевых слов `var` или `val`.
Свойство, объявленное, как `val` доступно только для чтения, а свойство `var` можно изменять

```kotlin
class Person(
	val name: String,
    var isMarried: Boolean
)
```

Краткое объявление класса `Person` скрывает традиционную реализацию: это класс с приватными полями, которые инициализируются в конструкторе и доступны через соответствующие методы чтения.

Этот класс можно использовать в Java вот так

```java
Person person = new Person("Bob", true);
System.out.println(person.getName());
System.out.println(person.isMarried());
```

В правилах именования методов доступа есть исключение: если имя свойства начинается с префикса `is`, никаких дополнительных префиксов не добавляется для методов чтения. А методах записи добавляется префикс `set`

*Жемеров Д., Исакова С. Kotlin в действии. стр.47*

## Kotlin обращается через методы доступа/записи

Можно не вызывать методы чтения, а обращаться к свойству непосредственно.
Логика та же, но код становиться более лаконичным.
Методы записи имзеняемых свойств работают точно так же.

Точно так же можно работать и с Java классами: обращаться к полю, а под капотом будет обращение черезе get/set-методы

*Жемеров Д., Исакова С. Kotlin в действии. стр.48*

## Собственные методы доступа

Если нужно добавить логику в метод лоступа, то его можно определить явным образом.

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
      get() {
          return height == width
      }
}
```

Фигурные скобки можно опустить

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
      get() = height == width
}
```

*Жемеров Д., Исакова С. Kotlin в действии. стр.48-49*

## Каталоги и пакеты

Как и в Java, можно определить `package` вначале и `import`.
Kotlin не делает различий между импортом классов и функций, что позволяет импортировать любые объявления с помощью ключевого слова `import`

Программируя на Kotlin, вы можете поместить несколько классов в один файл и выбрать любое имя для этого файла. Также можно использовать любую структуру каталогов.
Однако в большинстве случаев хорошим тоном считается следовать структуре каталогов в Java

*Жемеров Д., Исакова С. Kotlin в действии. стр.49-51*

## Определение enum

```kotlin
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
```

Это тот редкий случай, когда в объявлении на Kotlin используется больше ключевых слов, чем в Java: `enum class` против `enum` в Java.

В случае использования методов в enum, список констант должен быть отделен от определений методов с помощью точки с запятой

В Kotlin `enum` - это так называемое "мягкое" ключевое слово.

*Жемеров Д., Исакова С. Kotlin в действии. стр.51-52*

## `when`

Конструкцию `when` можно считать заменой конструкции `switch` в Java, но с более широкими возможностями.
Подобно `if`, оператор `when` - это выражение, возвращающее значение, поэтому вы можете написать функцию с телом-выражением, которая  напрямую возвращает выражение `when`

```kotlin
fun getMnemonic(color: Color) =
	when (color) { // сразу возвращает выражение `when`
        Color.RED -> "Каждый" 
                Color.RED -> "Каждый"
                Color.ORANGE -> "Охотник"
                Color.YELLOW -> "Желает"
                Color.GREEN -> "Знать"
                Color.BLUE -> "Где"
		        Color.INDIGO -> "Сидит"
        		Color.VIOLET -> "Фазан"
    }
```

Код находит ветку, соответствующую заданному значению цвета.
В отличие от Java, в Kotlin не нужно добавлять в каждую ветку инструкцию `break`.

*Жемеров Д., Исакова С. Kotlin в действии. стр.51-53*

## `when` и `else`

Вместо `default` из `switch` Java, в `when` Kotlin можно определить ветку `else`
Если ни одно из условий не выполнится произойдет переход в ветку `else`

*Жемеров Д., Исакова С. Kotlin в действии. стр.54*

## Объединение веток `when`

В одну ветку можно объединить несколько значений, разделив их запятыми

```kotlin
fun getWarmth(color: Color) = when(color) {
    Color.RED, Color.Orange, Color.YELLOW -> "теплый"
    Color.GREEN -> "нейтральный"
    Color.BLUE, Color.INDIGO, Color.VIOLET -> "холодный"
}
```

*Жемеров Д., Исакова С. Kotlin в действии. стр.53*

## Множества

Множество - это коллекция, порядок элементов которой не важен
Два множества считаются равными, если содержат одинаковые элементы.
В Kotlin можно создать множества при помощи функции `setOf`
Эти два множества равны `setOf(YELLOW, RED)` и `setOf(RED, YELLOW)`

*Жемеров Д., Исакова С. Kotlin в действии. стр.54*

## `when` с произвольными объектами

В отличие от `switch` в Java, который требует использовать константы (перечисления, строки и числовые литералы) в определениях вариантов, оператор `when` в Kotlin позволяет использовать любые объекты.

```kotlin
fun mix(c1: Color, c2: Color) {
    when (setOf(c1, c2)) {
        setOf(RED, YELLOW) -> ORANGE
        setOf(YELLOW, BLUE) -> GREEN
        setOf(BLUE, VIOLET) -> INDIGO
        else -> throw Exception("Грязный цвет")
    }
}
```

Возможность использования любых условных выражений в ветвях `when` позволяет писать лаконичный и выразительный код.

*Жемеров Д., Исакова С. Kotlin в действии. стр.54*

## `when` без агрументов

В выражениях `when` без аргумента условием выбора ветки может стать любое логическое выражение.

```kotlin
fun mixOptimized(c1: Color, c2: Color) {
    when {
        (c1 == RED && c2 == YELLOW) || (c1 == YELLOW && c2 == RED) -> ORANGE
        (c1 == BLUE && c2 == YELLOW) || (c1 == YELLOW && c2 == BLUE) -> GREEN
        (c1 == BLUE && c2 == VIOLET) || (c1 == VIOLET && c2 == BLUE) -> INDIGO
        else -> throw Exception("Грязный цвет")
    }
}
```

*Жемеров Д., Исакова С. Kotlin в действии. стр.54*

## Атоматические приведение типов (Smart Cast)

В Kotlin принадлежность переменной к определенному типу проверяется с помощью оператора `is`.
Эта проверка подобна оператору `instanceOf` в Java. Но в Java для получения доступа к нужным свойствам и методам необходимо выполнить явное приведение после проверки оператором `instanceOf`.
Компилятор Kotlin делает жту работу за вас. Если вы проверили переменную на соответствие определенному типу, приводить ее к этому типу уже не нужно.

```kotlin
if (s is Sum) {
    return eval(e.right) + eval(e.left)
}
```

Автоматическое приведение работает, только если переменная не изменялась после проверки оператором `is`

*Жемеров Д., Исакова С. Kotlin в действии. стр.57*

## Явное приведение типов

```kotlin
val n = e as Num
```

*Жемеров Д., Исакова С. Kotlin в действии. стр.58*

## `when` для проверки типа

Выражение `when` не ограничивается проверкой равенства. К примеру, так можно проверить типа используя `when`

```kotlin
when (e) {
    is Num -> e.value
    is Sum -> eval(e.right) + eval(e.left)
    else -> throw IllegalArgumentException("Unknown expression")
}
```

*Жемеров Д., Исакова С. Kotlin в действии. стр.59*

## В Kotlin нет тернарного оператора

`if (a > b) a else b` в Kotlin действует как `s > b ? a : b` в Java.
В Kotlin тернарный оператор отсутствиет, поскольку в Kotlin выражение `if` возвращает значение

*Жемеров Д., Исакова С. Kotlin в действии. стр.58*

## Фигурные скобки в `if` можно опустить

Фигурные скобки необязательны, если тело функции состоит только из одного выражения `if`.
Если одна из веток `if` является блоком, ее результатом будет последнее выражение

*Жемеров Д., Исакова С. Kotlin в действии. стр.58*

## Блоки не только в `if`, но и в `when`

Оба выражение - `if` и `when` - позволяют определять ветки в виде блоков

```kotlin
when(e) {
    is Num -> {
        ptintln("...")
        ...
    }
    is Sum -> {
        ...
    }
}
```

*Жемеров Д., Исакова С. Kotlin в действии. стр.59*

## Циклы `while` и `do-while`

В языке Kotlin есть циклы `while` и `do-while`, и их синтаксис не отличается от синтаксиса соответствующих циклов в Java

*Жемеров Д., Исакова С. Kotlin в действии. стр.60*