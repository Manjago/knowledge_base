# Транзакции
## Историческая справка до транзакций в Spring
На заре разработки на Java (после появления JDBC, но до JEE, Spring и прочих каркасов) разработчики программно контролировали и управляли транзакциями в програмном коде.<br/>
КОгда появился EJB, разработчики получили возможность пользоваться управляемым контейнером транзакций (CMT), чтобы управлять ими декларативно. Но сложное объявление транзакций в дескрипторе развертывания EJB все же было трудно поддерживать, а кроме того, оно излишне усложняло обработку транзакций<br/>
Некоторые разработчики предпочитали иметь контроль над транзакции и поэтому выбирали управляемые компонентами транзакции (BMT), чтобы управлять ими программно. Там не менее, сложность программирования с помощью JTA (Java Transaction API) тоже предпятствовало повышению производительности труда рзработчиков.<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 625_

## Локальные и глобальные транзакции
Независимо от того, используется ли Spring или нет, при разработке приложения, взаимодействующего с БД, приходится делать главный выбор между локальными и глобальными транзакциями<br/>
_Локальные_ транзакции характерны для отдельного транзакционного ресурса (к примеру, подключения через JDBC)<br/>
_Глобальные_ транзакции находятся под управлением контейнера и могут охватывать несколько транзакционных ресурсов<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 626_

## Глобальные транзакции в JTA и 2PC
В Java глобальные транзакции были реализованы в JTA. В таком случае своместимый с JTA диспетчер транзакций подключается ко многим транзакционным ресурсам через соответствующие диспетчеры ресурсов, способные взаимодействовать с диспетчером транзакций по протоколу **XA** (открытому стандарту, определяющему распределенные транзакции).<br/>
Кроме того, с помощью двухфазовой фиксации (2 Phase Commit - 2PC) обеспечивается правильное обновление или откат всех участвующих в транзакции сточников данных. При отказе любого из этих ресурсов будет выполнен откат всей транзакции.<br/>
Интерфейс JTA поддерживается всеми полноценными серверами приложений, совместимыми с JEE (JBoss, WebSphere, GlassFish и т.д.), а для автономых веб-приложений и контейнеров (вроде Tomcat и Jetty) сществуют комерческие и open source решения, обеспечивающие поддержку JTA/XA (к примеру Atomikos, JOTM и Bitronix)<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 627, 628_

## Стороны, принимающие участие в глобальной транзакции
* БД, система обмена сообщениями, система управления прелдприятием (ERP)...
* Диспетчер ресурсов, который обно предоставляется поставщиком сервера БД (к примеру) и отвечает за взаимодействие с этим ресурсовм. К примеру, для MySQL приходится взаимодействовать с `MysqlXADataSource`
* диспетчер транзакций JTA, отвечающий за управление, оординацию и синхронизацию состояния транзакции через протокол XA
* Приложение

_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 628_

## PlatformTransactionManager
Для создания транзакци и управления ими в Spring вместе с интерфейсом `PlatformTransactionManager` применяются интерфесы `TransactionDefinition` и `TransactionStatus`<br/>
В Spring предоставляется обширный ряд реализаций `PlatformTransactionManager`. К примеру:
* `CciLocalTransactionManager` - поддерживает JEE, JCA, CCI
* `DataSourceTransactionManager` предназначен для обощенных подключений через JDBC
* `JpaTransactionManager`
* `HibernateTransactionManager`
* `JmsTransactionManager`
* `JtaTransactionManager`
* `WebSphereUowTransactionManager`

и другие
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 628_

## ACID
Транзакци обладают четырьмя хорошо известными свойсвтами:
* atomicity (атомарность)
* consistency (согласованность)
* isolation (изолированность)
* durability (долговечность)

За их поддержку отвечают транзакционные ресурсы<br/>
Контролировать ACID транзакции нельзя, но можно контролировать ее распространение и время расространения, а также настроить в конфигурации доступность транзакции только для чтения и задавать уровень изоляции<br/>
Все эит установки инкапсулированы в интерфейсе `TransactionDefinition`<br/>
Этот интерфейс применяется в главном интерфейсе `PlatformTransactionManager` для поддержки транзакций.
```java
public interface PlatformTransactionManager {
	TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;
	void commit(TransactionStatus status) throws TransactionException;
	void rollback(TransactionStatus status) throws TransactionException;
}
```
Базовый метод `getTransaction()` получает `TransactionDefinition` в качестве аргумента и возвращает `TransactionStatus`. Последний служит для контроля выполнения транзакции<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 629_

## TransactionDefinition
```java
public interface TransactionDefinition {
	int PROPAGATION_REQUIRED = 0;
	int PROPAGATION_SUPPORTS = 1;
	int PROPAGATION_MANDATORY = 2;
	int PROPAGATION_REQUIRES_NEW = 3;
	int PROPAGATION_NOT_SUPPORTED = 4;
	int PROPAGATION_NEVER = 5;
	int PROPAGATION_NESTED = 6;
	int ISOLATION_DEFAULT = -1;
	int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;
	int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;
	int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;
	int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;
	int TIMEOUT_DEFAULT = -1;
	int getPropagationBehavior();
	int getIsolationLevel();
	int getTimeout();
	boolean isReadOnly();
	@Nullable String getName();
}
```
* `getTimeout()` возвращает помежуток времени в милисекундах, в течении которого транзакция должна быть завершена
* `isReadOnly()` - доступна ли транзакция только для чтения
* `getName()` - имя транзакции
* `getIsolationLevel` - в нем определяются изменени я в данных, доступные другим транзакциям. Подробнее в таблице ниже

| Уровень изоляции | Описание |
| --- | --- |
| `ISOLATION_DEFAULT` | Стандартный уровень изоляции базового информационного хранилища |
| `ISOLATION_READ_UNCOMMITTED` |  Самый низкий, на котором транзакцию едва ли можно назвать таковой, поскольку на нем доступны данные, модифицированные в других незавершенных транзакциях |
| `ISOLATION_READ_COMMITTED` | Стандартны уровень изоляции в большинстве БД.<br/>На эом уровне гарантируется, что нельзя читать  данные, которые еще не зафиксированы в текущей транзакции. Но данные, прочитанные в одной транзакции могут быть обновлены в других. |
| `ISOLATION_REPEATABLE_READ` | Более строгий уровень, чем `ISOLATION_READ_COMMITTED`.<br/>На этом уровне гарантируется, что после выборки данных можно произвести повторную выборку, по крайней мере, того же самого набора данных.<br/>Если же новые данные были введены в других транзакциях, вновь введенные данные могут быть извлечены |
| `ISOLATION_SERIALIZABLE` | Самый дорогостоящий и надежный уровень.<br/>На этом уровне все транзакции трактуются как выполняемые последовательно одна за другой |

* `getPropagationBeavior()` определяет, что произойдет с транзакционным вызовом, в зависимости от того, существут ли активная транзакция. Подробнее в таблице ниже

| Режим распространения | Описание |
| --- | --- |
| `PROPAGATION_REQUIRED` | Поддерживает транзакцию, если она уже существует.<br/>А если транзакция отсутствует, то начинается новая транзакция |
| `PROPAGATION_SUPPORTS` | Поддерживает транзакцию, если она уже существет.<br/>А если транзакция отсутствует,то выполнение осуществляется без транзакции |
| `PROPAGATION_MANDATORY` | Поддерживает транзакцию, если она уже существет<br/>А если активная транзакция отсутствует, то генерирует исключение |
| `PROPAGATION_REQUIRES_NEW` | Всегда начинает новую транзакцию.<br/>Если активная транзакция уже существет, она приостанавливается |
| `PROPAGATION_NOT_SUPPORTED` | Не поддерживает выполнение с активной транзакцией.<br/>Всегда выполняется без транзакций и приостанавливает любые существующие транзакции |
| `PROPAGATION_NEVER` | Всегда выполняется без транзакций, даже если имеется активная транзакция.<br/>Если же активная транзакция существет, генерируется исключение |
| `PROPAGATION_NESTED` | Выполняется во вложенной транзакции, если существет актинвая транзакция.<br/>А если транзакция отсутствует, то выполняется так, как будто установлено значение `PROPAGATION_REQUIRED` |

_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 631-632_

## TransactionStatus
```java
public interface TransactionStatus extends SavepointManager, Flushable {
	boolean isNewTransaction();
	boolean hasSavepoint();
	void setRollbackOnly();
	boolean isRollbackOnly();
	@Override void flush();
	boolean isCompleted();
}
```
Интерфейс `TransactionStatus` позволяет диспетчеру транзакций управлять выполнением транзакции.<br/>
В прикладном коде можно проверить, является ли транзакция новой или доступнадля чтения. <br/>
* `setRollbackOnly()` - вызывет откат и завершает активную транзакцию
* `hasSavepoint()` - возвращаетпризнак, обозначающий, имеетсяли в транзакции точка сохранения, т.е. транзакция создана, как вложенная из точки сохранения
* `flush()` - сбрасывает текущий сеанс работы в репозиторий, если это уместно (к примеру, если используется Hibernate)
* `isCompleted()` - возвращает признак завершения транзакции (фиксации или отката)

_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 633_
