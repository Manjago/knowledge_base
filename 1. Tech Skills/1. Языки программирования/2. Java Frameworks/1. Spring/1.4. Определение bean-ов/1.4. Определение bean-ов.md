# Определение bean'ов
* [Имя и псевдонимы](1.4.1.%20Имя%20и%20псевдонимы/1.4.1.%20Имя%20и%20псевдонимы.md)
* [Область видимости или scope](1.4.2.%20Область%20видимости%20или%20scope/1.4.2.%20Область%20видимости%20или%20scope.md)
* [Режимы автосвязывания и выбор между компонентами родственных типов](1.4.3.%20Режимы%20автосвязывания%20и%20выбор%20между%20компонентами%20родственных%20типов/1.4.3.%20Режимы%20автосвязывания.md)

## Получение Spring Bean, идентификаторы, псевдонимы
Каждому компоненту Spring bean может быть назначен идентификатор, имя или что то другое.<br/>
Экземпляр можно получить и без идентификатора или имени<br/>
У каждого компонента имеется по крайней мере одно имя, но их может быть несколько (через запятую). Все имена после первого - псевдонимы<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 92_

## Стереотипные аннотации
Аннотации `@Component`, `@Controller`, `@Repository`, `@Service` называют стереотипными, потому что они входят в состав пакета `org.springframework.stereotype`.<br/>
В этом пакете собраны все аннотации, применяемые для определения компонентов SpringBeans. Эти аннотации соотвествтуют также назначению определяемых компонентов.<br/>
`@Service` служит для определения служебных компонентов, которые выполняют сложные функции, предоставляя требующиеся услуги другим компонентам<br/>
`@Repository` служит для определения бинов предназначенных для сохранения и извлечения информации из базы данных<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 100_

## Component и Service
По существу, применение аннотации `@Component` дает тот же самый эффект, что и аннотация `@Service`. Обе аннотации указывают Spring на то, что помеченный ими класс является кандидатом на автоматическое обнаружение.<br/>
Если компонент не выполняет никако бизнес логики, а предоставляет, к примру, конфигурацию, то его стоит пометить как `@Component`.<br/>
Если же он выполняет бизнес-логику, то это уже `@Service`<br/>
На практике, `@Service` является частным случаем `@Component`<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 124_

## В стереотипных аннотацих можно задать имя Spring Bean (к примеру, @Component и @Bean)
К примеру `@Component("Agamemnon")`<br/>
Чтобы объявить псевдонимы в аннотации `@Bean`, можно воспользоватьс атрибутом `name`. Этот же атрибут используется по умолчанию.<br/>
Если аннотация `@Component` без аргументов, то по соглашению именования, имя компонента будет равно имени класса с заменой первой буквы  на строчную<br/>
аналогично для аннотации `@Bean`. Если не определено имя, то по соглашению, имя будет равно методу<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 100, 160, 162_

## Разрешение имен компонентов Spring Beans
Если в дескрипторе `<bean>` предусмотрен атрибут `id`, его значение служит в качестве имени компонента<br/>
Если `id` не указан, то Spring ищет атрибут `name`. Если он определен, то Spring использует первое имя, заданное в `name` (их может быть несколько)<br/>
Если нет ни `id`, ни `name`, то Spring пытается использовать имя класса в качестве имени компонента (если других компонентов с таким именем нет)<br/>
Если есть несколько компонентов без `id`, `name` и с одинаковым именем класса, Spring бросит `NoSuchBeanDefinitionException`<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 154_

## Получение все компонентов по типу
Для получения все зарегистрированных компонентов Spring Beans по типу можно воспользоваться методом `getBeansOfType(...)` у контекста.<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 155_

## Проверки id в xml
До версии Spring 3.1 атрибут `id` был равнозначен XML-идентификации (`xsd:id`), что накладывало ограничения.<br/>
Начиная с версии Spring 3.1, для атрибута `id` применяется идентификация `xsd:string`, а следовательно прежние ограничения сняты.<br/>
Однако, Spring по-прежнему проверяет однозначность идентификатора в атрибуте `id` во всем контексте.<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 155-156_

## Разрешение зависимостей создания компонентов Spring Beans (depends-on, @DependsOn)
В том случае, если в одном компоненте может быть получен другой компонент без автосвязывания, а через `context.getBean(...)`, получаемый компонент может быть не готов к использованию, так как для Spring такая зависимость не очевидна.<br/>
Чтобы вручную определить зависимость между компонетами Spring Beans, можно применить атрибут `depends-on="someBean"` в определении `<bean .../>` или аннотацию `@DependsOn("someBean")`<br/>
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 172-174_

## Наследование компонентов
Иногда может понадобиться целый ряд определений компонентов Spring Beans одного и того же типа или реализация общего для них интерфейса.<br/>
Трудности может вызвать, если компоненты должны совместно использовать общие параметры конфигурации.<br/>
Процесс поддержки общих параметров конфигурации в синхронно состоянии подвержен ошибкам и может отнять не мало времени.<br/>
Чтобы обойти подобное препятствие, Spring допускает определить в `<bean... />`компонент, от которого наслеюется определение свойств.<br/>
Из [примера](../examples/spring/src/main/java/ru/akhitev/kb/spring/parent) с [ресурсами](../examples/spring/src/main/resources/spring/parent)
```java
public class Character {
    private String name;
    private String guild;
    private boolean mainCharacter;

    // setters

    @Override
    public String toString() {
        return "Игрок {" +
                "имя: '" + name + '\'' +
                ", гильдия: '" + guild + '\'' +
                ", основной персонаж: " + mainCharacter +
                '}';
    }
}
```
```xml
<bean id="ogzeMember"
      class="ru.akhitev.kb.spring.parent.Character">
    <property name="guild" value="Орден Героев Забытых Эпох" />
    <property name="mainCharacter" value="true"/>
</bean>

<bean id="Endemeon" parent="ogzeMember"
      class="ru.akhitev.kb.spring.parent.Character">
    <property name="name" value="Эндемеон" />
</bean>
...
<bean id="Konich" parent="ogzeMember"
      class="ru.akhitev.kb.spring.parent.Character">
    <property name="name" value="Коныч" />
    <property name="mainCharacter" value="false"/>
</bean>
```
```java
ApplicationContext context = new GenericXmlApplicationContext("spring/parent/beans.xml");
System.out.println(context.getBeansOfType(Character.class));
```
Вывод
```
{ogzeMember=Игрок {имя: 'null', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: true}, Endemeon=Игрок {имя: 'Эндемеон', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: true}, Sansheg=Игрок {имя: 'Саншег', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: true}, Semetery=Игрок {имя: 'Семетери', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: true}, Eglin=Игрок {имя: 'Эглин', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: true}, Konich=Игрок {имя: 'Коныч', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: false}}
```
Если не нужно, чтобы можно было отдельно создавать родительский компонент, его можно пометить, как абстрактный с помощью аттрибута `abstract`
```xml
<bean id="ogzeMember" abstract="true"
```
Тогда вывод
```
{Endemeon=Игрок {имя: 'Эндемеон', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: true}, Sansheg=Игрок {имя: 'Саншег', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: true}, Semetery=Игрок {имя: 'Семетери', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: true}, Eglin=Игрок {имя: 'Эглин', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: true}, Konich=Игрок {имя: 'Коныч', гильдия: 'Орден Героев Забытых Эпох', основной персонаж: false}}
```
_Козмина Ю., Харроп Р., Шефер К., Хо К., Spring 5 для профессионалов. Стр. 188-189_
