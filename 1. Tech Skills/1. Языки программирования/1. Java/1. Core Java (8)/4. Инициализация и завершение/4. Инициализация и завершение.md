## Инициализация и завершение
### Перегрузка по аргументам, а не по возвращаемому значению
Перегруженные методы не разрешается различать по возвращаемому значению.<br/>
Чтобы не было неоднозначности вроде такой:
```java
void f() {...}
int f() {return 1;}
...
f();
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 151_

### Конструктор по умолчанию автоматически создается, только если никакого нет
Если нет никакого конструктора, java сделает один по умолчанию сам, чтобы можно было хоть как то инициализировать объект.<br/>
Но если есть хотя бы один конструктор, конструктор по умолчанию создан не будет.<br/>
Разработчик должен писать его сам, если он нужен.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 152_

### Сущность `this`
При вызове нестатических методоы, в них передается скрытый первый аргумент - ссылка не текущий объект.<br/>
Чтобы им воспользоваться и применяется слово `this`
```java
Banana a = new Banana();
Banana b = new Banana();
a.peel(1);
b.peel(2);
//можно представить, как
Banana.peel(a,1);
Banana.peel(b,2);
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 153_

### `this` в конструкторе
В конструкторе, через ключевое слово `this` вызывается другой конструктор объекта
```java
class Flower {
    String s = "def value";
    int petailCount = 0;

    Flower(String s) {
        this.s = s;
    }


    Flower(String s, int petailCount) {
        this(s);
        this.petailCount = petailCount;
    }
}
```
Вызывать так другой конструктор можно только из конструктора.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 155-156_

### Предназначение `finalize()`
`finalize()` предназначен только для случаев, когда объект размещен в памяти необычным образом.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 158_

### Уборка мусора
#### Отслеживание ссылок от стека и статической памяти
Если начать со стека и статического хранилища, можно добраться до используемых объектов. По каждой ссылке берется объект и все используемые в нем ссылки. Так получается дерево используемых объектов.<br/>
Остальные объекты подлежат уборке<br/>
#### Адаптивный механизм уборки мусора
##### Остановить и копировать
1. Программа останавливается;
1. все живые объекты копируются из одной кучи в другую;
1. неиспользуемые объекты остаются в первой куче.

При копировании происходит естественная дефрагментация.
Низкая эффективность из-за того, что:
1. существует 2 кучи;
1. копирование независимо от количества мусора.
##### Пометить и убрать
1. при поиске живых объектов со стека и статической памяти, мертвые объекты помечаются.
1. уборка происходит по окончанию процесса проверки

Этот процесс тоже требует остановки программы.<br/>
Если уборщик решит дефрагментировать кучу, это происходит внутри кучи.<br/>
Этот механизм может включаться JVM, если неиспользуемых объектов становиться меньше<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 162-163_

### JIT-компиляция и Java HotSpot
Компилятор JIT (Just-In-Time, на лету) частично или полностью конвертирует программу в "родной" машинный код<br/>
Благодаря этому этот код не нуждается в обработке виртуальной машиной и может выполняться гораздо быстрее.<br/>
При загрузке класса система находит файл `.class` и байт-код из этого файла переносится в память.<br/>
В этот момент можно просто провести компиляцию JIT для этого класса.<br/>
**Недостатки:**<br/>
* Это займет больше времени
* Увеличится размер исполняемого файла

**Альтернативная схема**: отложенное вычисление. код JIT-компилируется только тогда, когда это становится необходимым.<br/>
**Java HotSpot** делает это похожим образом с применением последовательной оптимизации кода при каждом его выполнении.<br/>
Таким образом, чем чаще код выполняется, тем быстрее он работает.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 164_

### Значения по умолчанию для полей и не для локальных переменных
Если речь идет о **поле** класса, то каждому примитивному типу присваивается значение по умолчанию, а каждому ссылочному - `null`<br/>
Если речь идет о локальных переменных, то значение по умолчанию не присваивается. Разработчик сам должен ее инициализировать.
```java
void f() {
    int i;
    i++; // Ошибка. Переменная i не иниициализирована
}
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 164_

### Поля инициализируются перед вызовом конструктора
Переменные класса инициализируются перед вызовом любых методов, даже конструкторов.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 167_

### Объекты статик инициализирются лениво
Статические поля инициализируются только при создании первого объекта или при обращении к его статическим данным.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 170_

### Конструктор - статический метод
Конструктор неявно является статическим методом<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 170_

### Блок инициализации статических объектов
Язык Java позволяет сгруппировать несколько действий по инициализации объектов static в статическом блоке инициализации.
```java
public class Spoon {
    static int i;
    static {
        i = 47;
    }
}
```
Этот блок выполняется только при создании первого объекта или при обращении к его статическим данным.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 171_

### Блок нестатичской инициализации выполняется до конструкторов
Секция инициализации экземпляра выполняется раньше любых конструкторов<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 173_

### Vararg
*Vararg* - список аргументов переменной длинны.<br/>
Позволяет избавиться от необходимости явной записи синтаксиса массивов. Компилятор делает это автоматически<br/>
```java
void someMethod(SomeClass... args) {
    for (SomeClass arg : args) {
        ...
    }
}
```
Массив тоже может быть принят, как список аргументов переменной длины<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 178_