# Структуры данных java.util.concurrent
## Общая идея
Общая стратегия, заложенная в основу этих контейнеров, выглядит так: изменения в контейнерах могут происходить одновременно с чтением при условии, что "читатели" видят только результаты завершенных изменений.<br/>
Изменение выполняется с отдельной копией части структуры данных (а иногда, с копией всей структуры), причем эта копия остается невидимой в процессе изменения. Только когда изменения будут завершены, измененная структура заменяет "оосновную" структуру данных в атомарной операции, после чего изменения становятся видны при чтении.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 1022_

## `CopyOnWriteArrayList`, `CopyOnWriteArraySet`
В `CopyOnWriteArrayList` запись приводит к созданию копии всего используемого массива. Исходный массив остается на месте, так что во время изменения копии возможно безопасное чтение. Когда изменение завершено, атомарная операция меняет массивы, и новое состояние будет отражено в последующих операциях чтения.<br/>
Одно из преимуществ `CopyOnWriteArrayList` заключается в том, что этот контейнер не выдает исключение `ConcurrentModificationException` при использовании нескольких итераторов для перебора и модификации списка (не придется писать специальный защитный код для защиты от таких исключений)<br/>
`CopyOnWriteArraySet` используется `CopyOnWriteArrayList` для реализации своего поведения.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 1022_

## `ConcurrentHashMap`, `ConcurrentLinkedQueue`
`ConcurrentHashMap` и `ConcurrentLinkedQueue` используют сходные средства, чтобы обеспечить возможность паралельного чтения и записи, но копируются и изменяются только части контейнера (а не весь). Операции чтения не "увидят"изменения, пока те не будут закреплены в контейнере. `ConcurrentHashMap` не возбуждает `ConcurrentModificationException`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 1022_

## Сравнение Производительности `java.util.concurrent` и `synchronized`-контейнеров
Если ограничиться чтением из контейнера без блокировок (из `java.util.concurrent`), операции с ним будут выполнятьс намного быстрее, чем с его `synchronized`-аналогом, из-за дополнительных затрат на установление и снятие блокировок.<br/>
Этот принцип српведлив и при небольшом количестве операций записи<br/>
Синхронизированный контейнер `ArrayList` обеспечивает примерно постоянную производительность независимо от количества операций чтения и записи. `CopyOnWriteArrayList` работает намного быстрее при отсутствии операций записи, но даже при пяти операциях записи наблюдается значительный рост производительности.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 1022, 1026_