# Массивы

## Плюсы массивов
Массив в Java - наиболее эффективный способ организации размещения последовательности элементов.<br/>
Массив заметно быстрее `ArrayList`, который построен на его основе.<br/>
Однако, за это приходится платить: размер массива фиксирован.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 602_

## Создание массива с помощью `new` и без
```java
int[][][] a = new int[2][2][4];
```
```java
int[][] a = {
    {1, 2, 3},
    {4, 5, 6}
};
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 608_

## Чем заполняется инициализирующийся массив по умолчанию?
При создании объекта массива его ссылки инициализируются значениями `null`<br/>
Массивы примитивов заполняются нулями для числовых типов, `(char)0` для `char`, `false` для `boolean`.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 606_

## Динамическое создание массива объектов
```java
new BerylliumSphere[] { new BerulliumSphere(), new BerulliumSphere() }
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 606_

## Отложенное определение длинны массива
```java
int[][][] a = new int[7][][];
for (int i = 0; i < a.length; i++) {
    a[i] = new int[5];
    for (int j = 0; j < a[i].length; j++) {
        a[i][j] = new int[4];
    }
}
```
Первая конструкция `new` создает массив, у которого первый элемент имеет размер, а остальные неопределены.<br/>
Вторая конструкция `new` в цикле заполняет элементы, но оставляет третий индекс неопределенным до вызова третьей конструкции `new`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 609_

## Массив объектов - объект
Можно взять ссылку, присоединенную к одному объекту массива и присвоить ее другому объекту массива<br/>
```java
a = d;
```
Теперь и массив `a`, и массив `d` указывают на один и тот же массив в общей куче<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 606_

## Массивы примитивов
Массивы примитивов хранят не ссылки, а реальные значения.
_Эккель Б. Философия Java. 4-е полное изд. Стр. 606_

## Нельзя сделать обобщенный массив
*Нельзя* создать массив параметризованного типа
```java
Peel<Banana>[] peels = new Peel<Banana>[10]; // Недопустимо!!!
```
Стирание уничтожает информацию о параметрах-типах, а для обеспечения безопасности типа массив должен знать точный тип хранящихся в нем объектов<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 612_

## Тип массива может быть параметризован в обобщенном классе или методе
Однако сам тип массива может быть параметризован
```java
class ClassParameter<T> {
    public T[] f(T[] arg) {return arg; }
}
...
class MethodParameter {
    public static <T> T[] f(T[] arg) {return arg; }
}
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 612_

## Массивы и уборка мусора
В Java не приходится заботиться о жизненном цикле массива<br/>
Уборщик мусора сам позаботиться об уничтожении массива, когда он перестанет быть нужен<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 607_

## Что именно показывает `length`?
Метод массива `length` показывает *сколько можно разместить* элементов в массив.<br/>
Он *не* показывает сколько находится элементов в массиве!<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 606_

## `Arrays.deepToString`
Метод `Arrays.deeptoString` (введенный в Java SE 5) преобразует многомерный массив в `String`<br/>
```java
int[] a = {
    {1, 2, 3},
    {4, 5, 6}
};
System.out.println(Arrays.deepToString(a));
// [[1, 2, 3], [4, 5, 6]]
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 608_

## Наполнение массива с `Arrays.fill`
Метод `Arrays.fill` предназначен для заполнения массива одинаковыми данными. К примеру, для тестов<br/>
Одно и то же значение или ссылка на один и тот же объект копируется во время ячейки<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 614_

## Быстрое копирование массива с использованием `System.arraycopy`
Статический метод `System.arraycopy` способен копировать массив быстрее, чем при ручном переборе `for`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 624_

## Ограничения `System.arraycopy`
Во время работы этого метода не выполняетя автоматической упаковки или распаковки примитивов и объекты не дублируются (копируются ссылки на них).<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 625_

## Сравнение массивов с `Arrays.equals`
Для сравнения массивов можно использовать перегруженный метод `Arrays.equals`.<br/>
Он сравнивает количество элементов в массиве и проверяет эквивалентность соотвествующих элементов.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 625_

## Сортировка при помощи `Arrays.sort` и реализации `Comparable`
Реализовав интерфейс `Comparable` и определив метод `compareTo` можно описать логику сравнения, которая будет использована при сортировке массива методом `Arrays.sort`
_Эккель Б. Философия Java. 4-е полное изд. Стр. 627_

## Обратный порядок сортировки при Arrays.sort
Если во второй параметр `Arrays.sort` передать `Collections.reverseOrder()`, то массив будет отсортирован в обратном порядке<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 628_

## Сортировка независимо от регистра
Если во второй параметр `Arrays.sort` передать `String.CASE_INSENSITIVE_ORDER`, то массив будет отсортирован без учета регистра<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 630_

## Алгорит сортировки Java
Алгоритм сортировки из стандартной библиотеки Java разработан с учетом максимальной эффетктивности для сортируемого типа: для простейших типов используется быстрая сортировка (quick sort), а для объектов применяется устойчивая сортировка слиянием (stable merge).<br/>
Поэтому не стоит без необходимости тратить время на разработку своего эффективного метода сортировки, пока профайлер не покажет, что с ней есть проблемы.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 630_

## `binarySearch` в отсортированном массиве
Как только массив отсортирован, в нем можно быстро найти определенный элемент, используя `Arrays.binarySearch(...)`<br/>
Однако, при поиске в неотсортированном массиве результат может быть непредсказуем<br/>
Метод `Arrays.binarySearch(...)` возвращает большее или равное нулю значение (позиция искомого элемента в массиве), если элемент был найден или отрицательное значение в противном случае.<br/>
```java
int[] someArray = ...;
	int numberWeNeedToFind = 322;
	Arrays.sort(someArray);
	System.out.prinln("Sorted array: " + Arrays.toString(someArray));
	int itsLocation = Arrays.binarySearch(someArray, numberWeNeedToFind);
	if (itsLocation >= 0) {
		System.out.println("Location of " + numberWeNeedToFind + " is " + itsLocation);
	}
```
Вывод
```
Sorted array: [120, 140, 200, 207, 258, 258, 278, 288, 322, 429, 511]
Location of 322 is 8
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 631_

## Бинарный поиск и дупликаты
Если в массиве есть дупликаты, метод `Arrays.binarySearch(...)` не гарантирует, какой именно из дупликатов будет найден.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 632_

## Бинарный поиск после сортировки с компаратором
Если массив был отсортирован с применением компаратора, то тот же компаратор необходимо включить в `Arrays.binarySearch(...)` третьим параметром
```java
Arrays.sort(someArray, String.CASE_INSENSITIVE_ORDER);
int location = Arrays.binarySearch(someArray, numberWeNeedToFind, String.CASE_INSENSITIVE_ORDER);
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 632_