# Повторное использование классов
## Композиция
Композиция - просто определение и использование классов внутри класса.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 206-209_

## Вызов конструктора родителя в конструкторе по умолчанию
Даже если конструктор класса-потомка не определен, компилятор сгенерирует конструктор по умолчанию, в котором также вызывается конструктор базового класса<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 212_

## Если у предка конструктор с параметрами
Если у предка конструктор с параметрами и если не вызвать конструктор предка в конструкторе потомка, то компилятор "пожалуется" на то, что не может обнаружить конструктор `SomeParent()`. Вдобавок, вызов конструктора базового класса должен быть первой командой в конструкторе производного класса<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 213_

## Аннотация `@Override`
В Java SE5 появилась аннотация `@Override`.<br/>
Если вы собираетесь переопределить метод, используйте аннотацию `@Override`, и компилятор выдаст ошибку, если вместо переопределения будет случайно выполнена перегрузка<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 221_

## Восходящее преобразование (Upcasting)
Термин возник по историческим причинам: традиционно на диаграммах наследования корень иерархии изображался у верхнего края страницы, а диаграмма разраталась к нижнему краю страницу.<br/>
Преобразование от производного типа к базовому требует движения вверх по диаграмме, поэтому часто называется **восходящим** преобразованием.<br/>
Восходящее преобразование всегда безопасно, так как это переход от конкретного типа к более общему типу.<br/>
Иначе говоря, производный класс является надстройкой базового класса.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 224-225_

## Неизменные аргументы
Java позволяет объявлять неизменными аргументы метода, с помощью ключевого слова `final` в списке аргументов<br/>
Это означает, что метод не может изменить значение, на которое указывает передаваемая ссылка.
```java
public class FinalArguments {
    void with(final Gizmo g) {
        // g = new Gizmo Запрещено! g объявлено final
    }

    void f(final i) {
        //i++; Запрещено! Неизменные примитивные типа доступны только для чтения
    }   
}
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 229_

## Методы `final` и оптимизация
В ранних реализациях Java, применение ключевого слова `final` давало возможность компилятору вместо вызова этого метода, делать его *inline* (подставить на место вызова копию реального кода)<br/>
Это позволяло избежать издержек вызова методов. Для больших методов это приводило к разбуханию программы.<br/>
В последних версиях JVM (5, 6, ...), виртуальная машина сама выявляет подобные моменты и устраняет лишние передачи управления для оптимизации.<br/>
Использование ключевого слова `final` для оптимизации нежелательно<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 230_

## `private` при наследовании
Переопределение применимо только к компонентам интерфейса базового класса.,<br/>
Иначе говоря, вы должны иметь возможность выполнить восходящее преобразование объекта к его базовому классу и вызвать тот же самый метод.<br/>
Если метод объявлен, как `private`, он не является частью интерфейса базового класса; это просто некоторый код, скрытый внутри класса, у которого оказалось то же имя.<br/>
Если вы создаете в производном классе **одноименный** метод со спецификотором `public`, `protected` и с доступом в пределах пакета, то он никак не связан с закрытым методом базового класса.<br/>
Так как `private` метод недоступен и фактически невидим для окружающего мира, он не влияет ни на что, кроме внутренней организации кода в классе, где он был описан.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 231_

## Инициализация объектов
Скомпилированный код находится в отдельном файле.<br/>
Этот файл не загружается, пока не возникнет такая необходимость.<br/>
Загрузка происходит при создании первого объекта или при обращении к статическим полям или методам.<br/>
Все статические объекты и блоки кода инициализируются в том порядке, в котором они записаны в определении класса.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 233_

## Инициализация при наследовании
Если у класса обнаруживается предок, загружается сначала он. Если и у него есть предок, то загружается предок. И так цепочка раскручивается до корневого класса.<br/>
Затем производится инициализация классов обратно по цепочке, от корневого класса к классу, в котором изначально возникла необходимость.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 235_

## Позднее связывание
Проблема неоднозначности при наследовании в Java решается благодаря позднему связыванию (late binding, dynamic binding, runtime binding)<br/>
Существует механизм определения фактического класса объекта во время работы программы для вызова нужного метода.<br/>
Компилятор не знает конкретный класс объекта, но механизм вызова метода его определяет и вызывает соответствующее тело метода.
```java
abstract class Ship {
...
    public move() {...}
}

class MillitaryShip extends Ship {
    @Override
    public move() {...}
}

class TradeShip extends Ship {
    @Override
    public move() {...}
}

public class Launcher {
    public static void main(String[] args) {
        Ship s = someInitialiser();
        s.move(); // Тут позднее связывание
    }
}
```
Механизм позднего связывания используется для всех методов, кроме методов, помечанных ключевым словом `final` и приватных методов (они являются `final` по умолчанию).<br/>
Теоретически, используя `final` можно дать компилятору сгенерировать более эффективный код. Однако влияние незначительно и лучше не зацикливаться на этом<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 241_