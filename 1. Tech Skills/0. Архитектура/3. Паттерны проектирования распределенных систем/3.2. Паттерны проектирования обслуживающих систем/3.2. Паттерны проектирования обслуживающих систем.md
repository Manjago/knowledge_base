# Паттерны проектирования обслуживающих систем
## Реплицированные сервисы с распределением нагрузки
### Сервисы без внутреннего состояния
Сервисы без внутреннего состояния (stateless) не требуют для своей работы сохранения состояния.<br/>
Системы не хранящие состояние, реплицируются для обеспечения избыточности и масштабируемости.<br/>
Горизонтально масштабируемые системы поддерживают растущее количество пользователей путем добавления дополнительных копий сервиса<br/>
При этом, балансировщик нагрузки не только равномерно распределяет нагрузку, но и предоставляет общее сетевое имя<br/>
В кубернетес, балансировщик можно сделать с помощью объекта `Service`<br/>
![Общая схема](img/stateless_general.png)<br/>
_Бёрнс Б., Распределенные системы. Паттерны проектирования. Стр. 82-83_

### Сервисы с закреплением сессии
Часто лучше обеспечить направление запроса конкретного пользователя определенному экземпляру сервиса<br/>
Иногда это может быть обусловлено кешированием пользовательских данных<br/>
Закрепление сессий обычно реализуется путем хеширования IP-адресов клиента и сервера<br/> 
![Общая схема](img/stateful_general.png)<br/>
_Бёрнс Б., Распределенные системы. Паттерны проектирования. Стр. 87-89_

### Кэширование
В простом виде, для http, кэширующий прокси представляет собой обычный HTTP-сервер, хранящий в памяти состояние запросов пользователей.<br/>
Если два пользователя запросят одну и ту же web-страницу, только один запрос будет адресован приложению, а второй будет обслужен из памяти кэша.<br/>
К примеру, если приложение выполняет сложную обработку, и визуализацию данных, нэш не помешает.<br/>
Производительность кэша выражается в виде *коэффициента попадания запросов* - это доля запросов, ответ на которые содержится в кэше.<br/> 
Вариант релазиации - [varnish-cache](http://varnish-cache.org/)<br/>
_Бёрнс Б., Распределенные системы. Паттерны проектирования. Стр. 90, 106_

## Шардированные сервисы
В отличие от реплицированных сервисов каждая *копия шардированного сервиса (шард)* может обслужить только часть запросов<br/>
*Узаел балансировки нагрузки (корневой узел)* отвечает за изучение каждого запроса и перенаправление его соответствующему узлу (или узлам) для обработки<br/>
Если репликация сервиса обычно используется для построения stateless-сервисов, то шардирование - для сервисов, хранящих состояние (stateful)<br/>
_Бёрнс Б., Распределенные системы. Паттерны проектирования. Стр. 102_

### Пример шардирующего кэша
Это реализация кэша, стоящая между пользовательскими запросами и собственно распределенной реализацией кэша<br/>
![](img/sharded_cache.png)<br/>
Поскольку конкретный пользователь или запрос всегда соответствуют одному и тому же шарду, в случае его отказа кэш-промахи будут приходить до тех пор, пока шард не будет восстановлен.<br/>
Учитывая временность нахождения данных в кэше, такие кэш-промахи не являются проблемой сами по себе - система должна знать, где взять данные. Однако, на это время скорость будет снижена<br/>
_Бёрнс Б., Распределенные системы. Паттерны проектирования. Стр. 105_

#### Шардированный и реплицированный кэш одновременно
Бывает, что система настолько зависима от кэша в плане нагрузки и задержек, что потеря даже одного шарда неприемлема<br/>
Тогда можно применить шардирование с реплицированием шардов<br/>
_Бёрнс Б., Распределенные системы. Паттерны проектирования. Стр. 107_

### Шардирующая функция
Задача шардирующей функции - определить соответствие между запросами и шардами<br/>
`SHard = ShardingFunction(Req)`<br/>
Шардирующая функция часто реализуется с помощью хэш-функции и оператора взятия остатка от деления<br/> 
_Бёрнс Б., Распределенные системы. Паттерны проектирования. Стр. 114_

#### Консистентная шардирующая функция
При увеличении количества шардов (и изменении шардирующей функции соответственно), увеличивается число промахов, так как запросы уходят не на те шарды<br/>
Эту проблему может решить консистентная хэш-функция, которая гарантирует, что при количестве ключей `K` и увеличении количества шардов на `N`, не больше `K/N` запросов будет перенаправленно<br/>
_Бёрнс Б., Распределенные системы. Паттерны проектирования. Стр. 117_