# SQL
**SQL** — _декларативный_ язык программирования, применяемый для создания, модификации и управления _данными_ в _реляционной базе данных_, управляемой соответствующей _системой управления базами данных_.
## Запрос данных
### Запрос на выборку всех полей и всех строк из таблицы
```sql
SELECT *
FROM users u;
```
| Фрагмент запроса | Комментарий |
| --- | --- |
| `SELECT` | После `SELECT` мы пишем, какие поля мы хотим запросить |
| `*` | "Звездочка" обозначает _всё_ |
| `FROM` | После FROM мы пишем название таблицы, из которой нам нужно запросить данные |
| `users u` | После `users` я добавил `u`. Это сокращение имени таблицы.<br/>Его можно задать каким угодно<br/>Если у тебя много таблиц, то такие сокращения полезны, чтобы не запутаться |
### Запрос на выборку конкретных полей и всех строк из таблицы
```sql
SELECT u.email, u.group_id
FROM users u;
```
| Фрагмент запроса | Комментарий |
| --- | --- |
| `u.email, u.group_id` | Мы указали поля таблицы, которые хотим выбрать и поставили вначале префикс `u` (сокращение из `From users u`) |
### Запрос на выборку строк из таблицы, подходящих по условию
```sql
SELECT *
FROM users u;
WHERE u.email = 'some_email@mail.ru'
```
| Фрагмент запроса | Комментарий |
| --- | --- |
| `WHERE` | После `WHERE` мы пишем условия.<br/>Если речь идет о строках, то значение нужно указать в кавычках (`'...'`)<br/>В случае с числами кавычки не нужны. |
### Операторы сравнения
| Оператор | Комментарий | Пример |
| --- | --- | --- |
| `=` | Равно | `WHERE email = 'some@dom.com'` |
| `<>` или `!=` | Не равно | `WHERE group_id != 3` |
| `>`<br/>`<`<br/> | Строго больше/меньше чем | `WHERE cost < 100` |
| `>=`<br/>`<=`<br/> | Больше/Меньше чем, включая пограничное значение | `WHERE length >= 2` |
| `like` | Равно шаблону<br/>Тут символ `%` аналогичен `*` - лобое количество любых символов | `WHERE category like '%32%` |
| `in` | Одно из значений | `WHERE user_id in (132, 168, 195) |

### Логические операторы (сразу несколько условий)
| Оператор | Комментарий | Пример |
| --- | --- | --- |
| `AND` | И одно, и другое условия являются истинной | `WHERE cost < 100 AND group_id = 3` |
| `OR` | Хотя бы одно из условий являются истинной | `WHERE first_name != '' OR second_name != ''` |
| `NOT` | Отрицание.<br/>Истинно, если условие ложно | `WHERE NOT group_id = 3` |

Логические операторы, как и в математики комбинируются с помощью скобок
```sql
SELECT *
FROM users u
WHERE u.group_id = 3
AND (WHERE first_name != '' OR second_name != '')
AND cost < 100
```
### Сортировка
ЗА сортировку отвечает оператор `ORDER BY`
```sql
SELECT *
FROM users u
ORDER BY u.online
```
Если нужно отсортировать в обратном порядке, то нужно добавить `DESC`
```sql
SELECT *
FROM users u
ORDER BY u.online DESC
```
Чтобы отсортировать по нескольким полям, их нужно перечислить через запятую
```sql
SELECT *
FROM users u
ORDER BY u.online, u.cost
```

## Объединение таблиц
Пусть есть 2 таблицы:
**Users**
| id | name | department_id |
| --- | --- | --- |
| 1 | Владимир | 1 |
| 2 | Антон | 2 |
| 3 | Александр | 6 |
| 4 | Борис | 2 |
| 5 | Юрий | 4 |

**departments**
| id | name |
| --- | --- |
| 1 | Сейлз |
| 2 | Поддержка |
| 3 | Финансы |
| 4 | Логистика |

### Внутреннее объединение: INNER JOIN или просто JOIN
![](http://www.skillz.ru/images/sql_join/join-inner.gif)
Запрос вернет объединенные данные, которые пересекаются по условию, указанному в `INNER JOIN ON <..>`.<br/>
В нашем случае условие <таблица_пользователей>.<идентификатор_отдела> должен совпадать с <таблица_отделов>.<идентификатор><br/>
Внутреннее объединение `INNER JOIN` (синоним `JOIN`, ключевое слово `INNER` **можно опустить**).<br/>
Выбираются только совпадающие данные из объединяемых таблиц.<br/>
```sql
SELECT u.id, u.name, d.name AS d_name
FROM users u
INNER JOIN departments d ON u.department_id = d.id
```
Результат будет:
```
id name       d_name
-- --------   ---------
1  Владимир    Сейлз
2  Антон       Поддержка
4  Борис       Поддержка
3  Юрий        Логистика
```
В результате отсутствуют:
* пользователь Александр (отдел 6 - не существует)
* отдел Финансы (нет пользователей)

### Внешнее объединение
![](http://www.skillz.ru/images/sql_join/join-left.gif)
Чтобы получить данные, которые подходят по условию частично, необходимо использовать внешнее объединение - `OUTER JOIN`.<br/>
Такое объединение вернет данные из обеих таблиц (совпадающие по условию объединения) ПЛЮС дополнит выборку оставшимися данными из внешней таблицы, которые по условию не подходят, заполнив недостающие данные значением NULL.<br/>
Существует два типа внешнего объединения `OUTER JOIN` - `LEFT OUTER JOIN` и `RIGHT OUTER JOIN`. `OUTER` можно опустить.

#### LEFT JOIN
LEFT - указывает что "внешней" таблицей будет находящаяся слева (в нашем примере это таблица users).<br/>
Ключевое слово `OUTER` можно опустить. Запись `LEFT JOIN` идентична `LEFT OUTER JOIN`.
```sql
SELECT u.id, u.name, d.name AS d_name
FROM users u
LEFT JOIN departments d ON u.department_id = d.id
```
```
id      name          d_name
--      --------      ---------
1       Владимир      Сейлз
2       Антон         Поддержка
3       Александр     NULL
4       Борис         Поддержка
5       Юрий          Логистика
```
#### RIGHT JOIN
`RIGHT JOIN` вернет полный список департаментов (правая таблица) и сопоставленных пользователей.
```sql
SELECT u.id, u.name, d.name AS d_name
FROM users u
RIGHT JOIN departments d ON u.department_id = d.id
```
```
id      name        d_name
--      --------    ---------
1       Владимир    Сейлз
2       Антон       Поддержка
4       Борис       Поддержка
NULL    NULL        Финансы
5       Юрий        Логистика
```
#### Исклучение пересечение множеств
![](http://www.skillz.ru/images/sql_join/join-left-outer.gif)
```sql
SELECT u.id, u.name, d.name AS d_name
FROM users u
LEFT JOIN departments d ON u.d_id = d.id
WHERE d.id IS NULL
```
```
3       Александр     NULL
```
В выборке останется только 3#Александр, так как у него не назначен департамент.

_[Заметка про разные Join-ы](http://www.skillz.ru/dev/php/article-Obyasnenie_SQL_obedinenii_JOIN_INNER_OUTER.html)_