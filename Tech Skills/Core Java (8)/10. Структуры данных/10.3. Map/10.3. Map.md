# Map
## Методы `Map`
| Метод | Комментарий |
| ---- | ----- |
| `map.put(key, value)` | |
| `map.putAll(map)` | |
| `map.get(key)` | |
| `map.keySet()` | Возвращает `Set` |
| `map.values()` | Возвращает `Collection` |
| `map.containsKey(key)` | |
| `map.containsValue(value)` | |
| `map.remove(key)` | |
| `map.clear()` | |

Такой вызов `map.keySet().removeAll(map.keySet());` очистит карту<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 671_

## Методы `SortedMap`
| Метод | Возвращаемый тип | Описание |
| --- | --- | --- |
| `comparator()` | `Comparator` | Возвращает компаратор, используемый в map или `null` при естественной сортировке |
| `firstKey()` | `T` | Возвращает наименьшее значение ключа |
| `lastKey()` | `T` | Возвращает наибольшее значение ключа |
| `subMap(fromKey, toKey)` | `SortedMap` | Возвращает подкарту начиная с `fromKey` (*включительно*) и по `toKey` (*не* включая) |
| `headMap(toKey)` | `SortedMap` | Возвращает подкарту по `toKey` (*не* включая) |
| `tailMap(fromKey)` | `SortedMap` | Возвращает подкарту начиная с `fromKey` (*включительно*) |

_Эккель Б. Философия Java. 4-е полное изд. Стр. 672_
## Реализации `Map`
| Название класса/интерфейса | Описание |
| ----- | ----- |
| `HashMap` | Реализация карты на основе хэш-таблиц (используется вместо устаревшего `Hashtable`)<br/>Поиск и вставка занимают небольшое постоянное время<br/>Производительность можно настроить, указав в конструкторе особые значения для _емкости_ и _коэфицента загрузки_ |
| `LinkedHashMap` | Похожа на `HashMap`, но при переборе выдает пары в порядке их добавления или согласно принципу *LRU* (наименее используемые идут первыми, least-recent-first)<br/>Лишь немногим медленее `HashMap` за исключением перечисления элементов, где она быстрее за счет внутреннего связанного списка, отвечающего за порядок добавления элементов |
| `TreeMap` | Реализация `SortedMap` на базе красно-черного дерева.<br/>При переборе значений или ключей видно, что они соблюдают порядок, определющийся в `Comparable` или `Comparator`<br/>Область применения - выдача результатов в отсортированном виде.<br/>`TreeMap` - единственная карта с методом `subMap()`, который позволяет выделять из карты ее часть |
| `WeakHashMap` | Карта, состоящая из слабых ключей, которые не препятствуют освобождению объектов, на которые ссылается карта<br/>Если за пределами карты ссылок на ключ нет, он может быть удален сборщиком мусора |
| `ConcurrentHashMap` | Потоко-безопасная версия `Map`, не использующая синхронизационную блокировку |
| `IdentityHashMap` | Хэш-таблица, использующая для сравнения ключей оператор `==` вместо метода `equals()`<br/>Не для рядовых случаев. Используется в особых случаях |

_Эккель Б. Философия Java. 4-е полное изд. Стр. 670_

## Проверка наличия ключа или значения в `Map`
`containsKey` и `containsValue` проверяют наличие ключа или значения в Map<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 347_

## Получение `Set` ключей из `Map`
Метод `keySet`возвращает `Set` ключей `Map`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 349_

## Пример проблемы с `HashMap` из-за непереопределенного hashCode
Если не переопределить `hashCode`, наследуемый от `Object`, то может получиться такая ситуация<br/>
[Пример](examples/src/main/java/map/HashCodeProblemInHashMapExample.java)
```java
public class HashCodeProblemInHashMapExample {
    public static void main(String[] args) {
        Map<SomeClass, String> map = new HashMap<>();
        map.put(new SomeClass(1), "a");
        map.put(new SomeClass(2), "b");
        map.put(new SomeClass(3), "c");
        System.out.println(map.containsKey(new SomeClass(1)));
        System.out.println(map.get(new SomeClass(2)));
    }

    private static class SomeClass {
        private final int someCode;

        private SomeClass(int someCode) {
            this.someCode = someCode;
        }
    }
}
```
Вывод
```
false
null
```
Мы пытаемся получить значение по ключу с тем же значением поля (по логике, объекты равны), но ссылки на объекты разные, из-за чего и `Object.hashCode()` возращает разные значения. В итоге, объкты не найдены.<br/>
Решение - переопределить `equals` и `hashCode`, чтобы учитывалось поле, по которому мы логически сравниваем.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 374-675_

## Хэширование, индексация и строение `HashMap`
Изюминка хэширования - скорость. Оно позволяет провести поиск весьма оперативно. Так как _узким местом_ является поиск ключа, одни из решений этой задачи могло бы стать поддержание всех ключей в упорядоченном виде.<br/>
По сути, при хэшировании необходимо хранить ключи _где то_, где их можно потом быстро найти. Самая быстрая структура данных - *массив*, поэтому он используется для хранения информации о ключах.<br/>
Однако, после создания массива, его размер больше не может менться. При этом, хотелось бы содержать неограниченное число элементов в `HashMap`. Эту проблему можно решить, если в массиве хранить не сами ключи, а число, которое будет использоваться для индексации массива. Тем самым, для решений проблемы ограниченности массива, можно соотносить один *индекс* массива с несколькими ключами. Другими словами, не исключены *коллизии*.<br/>
Таким образом, процесс поиска значения начинается с вычисления хэш-кода и поиска его в массиве. Такой способ еще можно назвать *внешним связываением* - когда элемент массива содержит не конкретное значение, но указывает на цепочку значений. В этой цепочке обнаружение производится с помощью обычного линейного алгоритма, с помощью метода `equals(...)`<br/>
Такие "ячейки" часто назывкают *узловыми группами* (*buckets*). Чтобы распределение было более равномерным, количество узлов обычно выбирают из степеней числа 2 (в позних версиях) или из простых чисел (в ранних версиях).<br/>
По сути, `HashMap` - это массив списков `LinkedList`, поэтому она автоматически приспособена к возникновению коллизий - каждый новый элемент просто добавляется в конец соотвествующий группы.<br/>
Индекс часто вычисляется, как остаток от деления хэш-кода.<br/>
Индес вычисляется при вызове методов `get(...)` и `put(...)`<br/>
![HashMap internal structure](img/hashmapInternalStructure.png)<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 680-683_

## Факторы, влияющие на производительность `HashMap`
| Название на русском | Название в оригинале | Описание |
| --- | --- | --- |
| Емкость | Capacity | Количество узлов хэш-таблицы |
| Начальная емкость | Initial Capacity | Начальная емкость при создании хэш-таблицы<br/>'HashMap' и 'HashSet' позволяют указать начальную емкость в конструкторе |
| Размер | Szie | Количество заполненных узлов в таблице |
| Коэфицент загрузки | Load Factor | Отношение размер/емкость. У пустой таблицы - 0. У заполненной на половину - 5. |

Незначительно заполненная таблица практически не имеет коллизий и поэтому оптимальна для вставок и произвольного поиска (но замедляет перебор с использованием итератора).<br/>
В конструторах `HashMap` и `HashSet` может передаваться коэфицент загрузки. При достижении этого уровня заполнения контейнер автоматически увеличит емкость (количество узлов) примерно в 2 раза и перераспределит набор существующих элементов по новым позициям (перехэширует, rehashing).<br/>
По умолчанию, коэфицент загрузки равен *0,75*<br/>
Если понятно, что в таблице будет храниться много элементов, имеет смысл сделать _емкость_ достаточно большой, чтобы предотвратить частое перехэширование<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 704_

## `WeakHashMap`
Специальная карта для хранения _слабых_ ссылок.<br/>
Она разработанна, чтобы упростить  реализацию "канонического отображения": с целью экономии памяти для конкретного значения создается только один экземпляр. Когда программе понадобится этот объект, она выбирает его из `Map` и использует (вместо того, чтобы создавать с нуля).<br/>
Эту `Map` можно заполнить при инциализации или добавлять объекты по мере надобности.<br/>
Так как этот механизм предназначен для экономии памяти, очень удобно то, что `WeakHashMap` позволяет уборщику мусора удалять ключи и значения автоматически.<br/>
При помещении объекта в `WeakHashMap`, объекты будут автоматически "заворачиваться" в объекты `WeakReference`.
Подробнее о `Reference` можно посмотреть [в этом разделе](../../5.%20Виды%20Reference/5.%20Виды%20Reference.md)<br/>
[Пример](examples/src/main/java/map/WeakHashMapExample.java)
```java
public class WeakHashMapExample {
    public static void main(String[] args) {
        int size = 1000000;
        Key[] keys = new Key[size];
        WeakHashMap<Key, Value> weakHashMap = new WeakHashMap<>();
        IntStream.range(0, size).forEach(i -> {
            Key key = new Key(Integer.toString(i));
            Value value = new Value(Integer.toString(i));
            if (i % 3 == 0) {
                keys[i] = key; // Сохраняем как "настоящие" ссылки
            }
            weakHashMap.put(key, value);
        });
        System.gc();
    }

    private static class Key extends Element {
        private Key(String identifier) { super(identifier); }
    }

    private static class Value extends Element {
        private Value(String identifier) { super(identifier); }
    }

    private static class Element {
        private String identifier;

        private Element(String identifier) { this.identifier = identifier; }

        @Override
        public String toString() { return "Element{" + identifier + '\'' + '}'; }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Element element = (Element) o;
            return Objects.equals(identifier, element.identifier);
        }

        @Override
        public int hashCode() { return Objects.hash(identifier); }

        protected void finalize() { System.out.println("Finalizing " + identifier); }
    }
}
```
Вывод
```
...
Finalizing 145714
Finalizing 145715
Finalizing 145717
Finalizing 145718
Finalizing 145720
Finalizing 145721
Finalizing 145723
...
```
Пропускается каждый 3-ий элемент, благодаря добавлению его в массив<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 715_