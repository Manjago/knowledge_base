# Информация о типах
## RTTI и Reflection
*RTTI (Run-Time Type Identification)* - во время компиляции и последующего выполнения программы можно получить информацию о типах. Проверяется компилятором.<br/>
*Reflection* - применяется исключительно во время выполнения<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 451_

## Объект `Class` для хранения информации о классах и создании объектов
Специальный объект `Class` содержит информацию о классе.<br/>
Объект `Class` используется при создании всех _обычкновенных_ объекто любой программы.<br/>
Java выполняет операции RTTI с использованием объекта `Class` даже при выполнении явного преобразования типа.<br/>
Для каждого класса, используемого в программе, существует свой объект `Class`. При компиляции класса, , для него создается объект `Class` и сохраняется в одноименный файл `.class`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 454_

## Загрузка класса
Для создания объекта, JVM использует подсистему, называемую *загрузчиком класса*<br/>
Эта подсистема может включать цепочку загрузчиков, но существет только один *первичный загрузчик классов*, который является частью реализации JVM. Первичный загрузчик загружает *доверенные классы*, включая классы Java API<br/>
Все классы в JVM загружаются динамически, при первом использовании класса.<br/>
Конструктор класса тоже является статическим методом класса (хоть в нем и не присутствует ключевое слово `static`). Таким образом, вызов оператор `new` считается обращением к статическому члену класса.<br/>
При обращении к классу, загрузчик классов сначала проверяет, загружен ли объект `Class` для указанного типа.<br/>
При отрицательном результате загрузчик ищет файл `.class` с соответствующим именем.<br/>
В процессе загрузки, исполнительная система проверяет byte-код класса.<br/>
Как только объект `Class` для определенного типа окажется в памяти, в дальнейшем он используется при создании всех объектов этого типа.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 454_

## `Class.forName`
`Class.forName("SomeClass")` - высов статического метода класса `Class`, который возвращает ссылку на объект `Class` по имени класса (полное имя, включая имя пакета).<br/>
[Пример](examples/java/rtti/class_for_name/GetClassForName.java)<br/>
### `Class.forName` загружает класс
При вызове `Class.forName`, автоматически происходит его загрузка, если этого класса еще нет в памяти.<br/>
Если класс не найден, выбрасывается `ClassNotFoundException`<br/>
[Пример](examples/java/rtti/class_for_name/FaceClassNotFoundException.java)<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 455-456_

## `someObject.getClass()`
Если есть объект класса, можно вызвать метод `getClass()` для получения ссылки на объект `Class`, являющийся фактическим типом объекта<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 456_

## Некоторые методы `Class`
[Пример](examples/java/rtti/class_for_name/GetClassForName.java)<br/>

1. `getName()` - для получения полного имени класса;
1. `getSimpleName()` - для получения имени класса без имени пакета;
1. `getCanonicalname()` - для получения имени класса с именем пакета;
1. `isInterface()` - является ли объект `Class` интерфейсом
1. `getInterfaces()` - возвращает массив объектов `Class`, представляющим интерфейсы объекта
1. `getSuperClass()` - возвращает базовый класс
1. `newInstance()` - Создание экземпляра. Для этого должен быть конструктор по умолчанию [Пример newInstance](examples/java/rtti/class_for_name/ClassForNameNewInstance.java)

_Эккель Б. Философия Java. 4-е полное изд. Стр. 457-458_

## `SomeClass.class` лучше `Class.forName(...)`
Получить ссылку на `Class` можно и через литерал `.class`<br/>
[Пример](examples/java/rtti/take_class/GetClassViaLiteral.java)<br/>
Это проще и безопаснее - проверка осуществляется на этапе компиляции.<br/>
Кроме того, не вызывается лишний метод, а значит этот подход эффективнее<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 459_

## Ссылки на классы примитивов
[Пример](examples/java/rtti/take_class/ClassLiteralForPrimitives.java)<br/>
Литерал | Ссылка на объект Class
------------ | -------------
boolean.class | Boolean.TYPE
char.class | Character.TYPE
byte.class | Byte.TYPE
short.class | Short.TYPE
int.class | Integer.TYPE
long.class | Long.TYPE
float.class | Float.TYPE
double.class | Double.TYPE
void.class | Void.TYPE

_Эккель Б. Философия Java. 4-е полное изд. Стр. 459_

## Создание ссылки на объект `Class` с применением `.class` не приводит к автоматической инициализации объекта `Class`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 459_

## Подготовка класса к использованию
1. *Загрузка класса* - выполняется загрузчиком класса. Загрузчик находит byte-код
1. *Компоновка*
1. 1. проверяется byte-код,
1. 1. выделяется память для статических полей,
1. 1. при необходимости, разрешаются ссылки на другие классы, используемые в классе
1. *Инициализация*
1. 1. Если есть супер класс - выполняется его инициализация
1. 1. выполняются статические инициализаторы и блоки статической инициализации

Инициализация откладывается до первого обращения к статическому методу или не-константному статическому полю<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 459_

## Константа времени компиляции может читаться без инициализаци класса
```java
static final int compileTimeConst = 47; // Константа времени компиляции
static final int notCompileTimeConst = nextInt(1000); // Константа времени компиляции
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 460_

## Обобщенный `Class`
С Java5 можно ограничить тип объекта Class, на который указывает ссылка при помощи обощения.<br/>
[Пример без generic-а](examples/java/rtti/take_class/generic/WithOutGeneric.java)<br/>
[Пример с generic-ом](examples/java/rtti/take_class/generic/WithGeneric.java)
```java
Class intClass = int.class;
Class<Integer> genericIntClass = int.class;
genericIntClass = Integer.class; // то же
intClass = double.class;
// Недопустимо
// genericIntClass = double.class;
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 461_

## Ослабление ограничений обощений у `Class`
Ослабить ограничение у `Class<Integer>` заменив его на `Class<Number>` *не получится*, так как это объект `Class` для `Integer` не является субклассом объекта `Class` для `Number`<br/>
Для ослабления можно восползоваться записью `Class<?>`, что является эквивалентом `Class`, но является предпочтительным<br/>
Чтобы создать ссылку, ограниченную *типом или его подтипами*, нужно использоваться запись `Class<? extends SomeSuperClass>`<br/>
[Пример](examples/java/rtti/take_class/generic/WithGenericExtends.java)<br/>
```java
Class<? extends Number> bounded = int.class;
bounded = double.class;
bounded = Number.class;
```
Параметризация была добавлена для проверки на этапе компиляции<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 462_

## Метод `.cast(...)`
Метод `cast(...)` получает на входе объект и преобразует его к типу ссылки на `Class`<br/>
[Пример](examples/java/rtti/cast/CastExample.java)
```java
Building b = new House();
Class<House> houseType = House.class;
House h = houseType.cast(b);
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 464_

## `instanceOf` проверяет на `null`
`instanceOf` незаметно выполняет еще одну функцид - проверку на `null`.<br/>
Он возвращает `false`, если объект равен `null`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 677_

## `Class.isInstance()`
Метод `isInstance()` помогает избавиться от необходимости использовать громоздкие цепочки `instanceOf`
```java
public void someMathod(Pet pet) {
    for (Map<Class<? extends Pet>, Integer> pair : entrySet()) {
        if (pair.getKey().isInstance(pet)) ...
    } ...
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 472_

## Reflection
Существует дополнительная библиотека `java.lang.reflect`, которая состоит из классов `Field`, `Method`, `Constructor`<br/>
Можно использовать:
1. `Constructor` для создания новых объектов класса
1. методы `get`, `set` для чтения и записи значений полей класса, представленных объектами `Field`
1. использовать `invoke()`, чтобы вызвать методы, представленные `Method`

В самом классе `Class` имеются удобные методы для получения массивов этих объектов
1. `getFields()`
1. `getMethods()`
1. `getConstructors()`

_Эккель Б. Философия Java. 4-е полное изд. Стр. 480_